#!/usr/bin/env node
var path = require('path')
var configLib = require(path.join(__dirname, '../lib/config'))
var nopt = require('nopt')
var noptUsage = require('nopt-usage')
var pointer = require('json-pointer')
var extend = require('extend')
var shelljs = require('shelljs')
var moment = require('moment')
var fs = require('fs')
var crypto = require('crypto')

var knownOpts = {
  // 'benchmark': [String, Array],
  'build': [String, Array],
  // 'compiler': [String, Array],
  // 'experiment': String,
  'help': Boolean,
  // 'implementation': [String, Array],
  'input-size': String,
  'iteration-number': Number,
  'platform': String,
  'verbose': Boolean
}
var shortHands = {
  'b': ['--benchmark'],
  'bu': ['--build'],
  'c': ['--compiler'],
  'e': ['--experiment'],
  'h': ['--help'],
  'i': ['--implementation'],
  'is': ['--input-size'],
  'n': ['--iteration-number'],
  'p': ['--platform'],
  'v': ['--verbose']
}

var suiteRoot = path.join(__dirname, '../../../')

function deepcopy (o) {
  if (Array.prototype.isPrototypeOf(o)) {
    return extend(true, [], o)
  } else {
    return extend(true, {}, o)
  }
}

var runOutputSchemaPath = '/definitions/run'
var validRunOutput = configLib.createMatcher(runOutputSchemaPath)
function executeRun (config, options) {
  var runnerPath = path.join(config.location, '/' + config.compiler['runner-name'])
  var runnerArguments = config.implementation['runner-arguments'].join(' ')
  var status = shelljs.exec(runnerPath + ' ' + runnerArguments, {silent: !options.verbose})
  if (status.code !== 0) {
    console.log('Execution error for ' + runnerPath + ' with ' + runnerArguments + ':')
    console.log(status.output)
    process.exit(1)
  }

  var jsonOutputMatch = status.output.match(/\{.*\}/)
  var jsonOutput
  if (jsonOutputMatch === null) {
    console.log('Invalid output for ' + runnerPath + ' with ' + runnerArguments + ',')
    console.log('missing json result:')
    console.log(status.output)
    process.exit(1)
  }

  try {
    jsonOutput = JSON.parse(jsonOutputMatch)
  } catch (e) {
    console.log('Invalid output for ' + runnerPath + ' with ' + runnerArguments + ',')
    console.log('improperly formatted json result:')
    console.log(status.output)
    process.exit(1)
  }

  if (!validRunOutput(jsonOutput)) {
    console.log('Invalid output for ' + runnerPath + ' with ' + runnerArguments + ',')
    console.log('json object does not conform to ' + runOutputSchemaPath + ' schema:')
    console.log(status.output)
    process.exit(1)
  }

  return jsonOutput
}

configLib.config(suiteRoot, function (err, config) {
  if (err) {
    console.log(err)
    process.exit(1)
  }

  var description = {
    'benchmark': 'One of [' + config['benchmark-list'] + '], repeat to specify multiple benchmarks',
    'build': 'Build hash value, repeat to specify multiple builds',
    'compiler': 'One of [' + config['compiler-list'] + '], repeat to specify multiple compilers',
    'experiment': 'Path to experiment configuration file',
    'help': 'Display this help',
    'implementation': 'One of [' + config['implementation-list'] + '], repeat to specify multiple implementations',
    'input-size': 'One of [' + pointer.get(config.schema, '/definitions/experiment/properties/input-size/enum') + '], defaults to medium',
    'iteration-number': 'Number of times to execute the benchmark',
    'platform': 'Path to a configuration file describing the current hardware configuration'
  }
  var parsed = nopt(knownOpts, shortHands)

  if (parsed.help) {
    var usage = noptUsage(knownOpts, shortHands, description)
    console.log(usage)
    process.exit(1)
  }

  var options = {
    'platform': JSON.parse(fs.readFileSync(parsed.hasOwnProperty('platform') ? parsed['platform'] : path.join(suiteRoot, '/platforms/mba-2011/platform.json')))
  }

  // Build benchmarks if built versions are not available

  // Load builds
  var run = {
    results: {},
    platform: options.platform,
    experiment: {
      'type': 'experiment',
      'short-name': 'default',
      'input-size': parsed['input-size'] || 'medium',
      'iteration-number': parsed['iteration-number'] || 1
    }
  }
  var builds = parsed.build
  builds.forEach(function (configPath) {
    var runConfig = deepcopy(pointer.get(config, '/' + configPath))
    runConfig.experiment = {
      'type': 'experiment',
      'input-size': run.experiment['input-size']
    }
    // Expand run-time arguments
    configLib.expand(runConfig, {strict: true})

    var result = {
      build: runConfig,
      experiment: run.experiment,
      platform: run.platform,
      'times': []
    }

    if (parsed.verbose) {
      console.log('-------------- ' + runConfig.benchmark['short-name'] +
        ',' + runConfig.implementation['short-name'] +
        ',' + runConfig.compiler['short-name'] +
        ',' + run.platform['short-name'] +
        ' --------------')
    }
    for (var i = 0; i < run.experiment['iteration-number']; ++i) {
      if (parsed.verbose) {
        console.log('************** Iteration ' + i + ' ************')
      }
      var output = executeRun(runConfig, parsed)
      result.times.push(output.time)
    }

    var hash = crypto.createHash('sha1')
    hash.update(JSON.stringify({
      build: result.build,
      experiment: runConfig.experiment,
      platform: result.platform
    }))
    run.results[hash.digest('hex')] = result
  })

  var silentState = shelljs.config.silent
  shelljs.config.silent = true
  run.time = moment().format()
  var dir = path.join(suiteRoot, '/runs/', run.time)
  shelljs.mkdir('-p', dir)
  shelljs.ln('-s', dir, path.join(suiteRoot, '/runs/latest'))
  JSON.stringify(run, null, '  ').to(path.join(dir, '/run.json'))
  shelljs.config.silent = silentState
})
