#!/usr/bin/env node
var path = require('path')
var configLib = require(path.join(__dirname, '../lib/config'))
var nopt = require('nopt')
var noptUsage = require('nopt-usage')
var pointer = require('json-pointer')
var extend = require('extend')
var shelljs = require('shelljs')
var moment = require('moment')
var fs = require('fs')
var crypto = require('crypto')

var knownOpts = {
  // 'benchmark': [String, Array],
  'build': [String, Array],
  'clean': Boolean,
  // 'compiler': [String, Array],
  // 'experiment': String,
  'help': Boolean,
  // 'implementation': [String, Array],
  'input-size': String,
  'iteration-number': Number,
  'platform': String,
  'environment': String,
  'skip-output-verification': Boolean,
  'verbose': Boolean
}
var shortHands = {
  'b': ['--benchmark'],
  'bu': ['--build'],
  'c': ['--compiler'],
  'en': ['--environment'],
  'e': ['--experiment'],
  'h': ['--help'],
  'i': ['--implementation'],
  'is': ['--input-size'],
  'n': ['--iteration-number'],
  'p': ['--platform'],
  'v': ['--verbose']
}

var suiteRoot = path.join(__dirname, '../../../')

function deepcopy (o) {
  if (Array.prototype.isPrototypeOf(o)) {
    return extend(true, [], o)
  } else {
    return extend(true, {}, o)
  }
}

var runOutputSchemaPath = '/definitions/run'
var validRunOutput = configLib.createMatcher(runOutputSchemaPath)
function executeRun (config, options) {
  var checkOutput = !options['skip-output-verification'] && pointer.has(config, '/benchmark/output-check-arguments')
  var environmentRunPath = path.join(config.environment.location, '/run')
  var runnerPath = path.join(config.location, '/' + config.compiler['runner-name'])
  var runnerArguments = checkOutput
    ? config.implementation['runner-arguments-with-output-check'].join(' ')
    : config.implementation['runner-arguments'].join(' ')
  var cmd = environmentRunPath + ' ' + runnerPath + ' ' + runnerArguments
  var status = shelljs.exec(cmd, {silent: !options.verbose})
  if (status.code !== 0) {
    console.log("Execution error for '" + cmd + "':")
    console.log(status.output)
    process.exit(1)
  }

  var jsonOutputMatch = status.output.match(/\{.*\}/)
  var jsonOutput
  if (jsonOutputMatch === null) {
    console.log('Invalid output for ' + runnerPath + ' with ' + runnerArguments + ',')
    console.log('missing json result:')
    console.log(status.output)
    process.exit(1)
  }

  try {
    jsonOutput = JSON.parse(jsonOutputMatch)
  } catch (e) {
    console.log('Invalid output for ' + runnerPath + ' with ' + runnerArguments + ',')
    console.log('improperly formatted json result:')
    console.log(status.output)
    process.exit(1)
  }

  if (!validRunOutput(jsonOutput)) {
    console.log('Invalid output for ' + runnerPath + ' with ' + runnerArguments + ',')
    console.log('json object does not conform to ' + runOutputSchemaPath + ' schema:')
    console.log(status.output)
    process.exit(1)
  }

  if (checkOutput) {
    if (options.verbose) {
      process.stdout.write('Verifying output: ')
    }
    cmd = pointer.get(config, '/benchmark/location') + '/output/check ' +
      pointer.get(config, '/benchmark/output-check-arguments').join(' ')
    status = shelljs.exec(cmd, {silent: !options.verbose})
    if (status.code !== 0) {
      console.log("error for '" + cmd + "':")
      console.log(status.output)
      process.exit(1)
    }
    if (options.verbose) {
      process.stdout.write('valid\n')
    }
  }

  return jsonOutput
}

configLib.config(suiteRoot, function (err, config) {
  if (err) {
    console.log(err)
    process.exit(1)
  }

  var description = {
    'benchmark': 'One of [' + config['benchmark-list'] + '], repeat to specify multiple benchmarks',
    'build': 'Build hash value, repeat to specify multiple builds',
    'clean': 'Clean the runs folder',
    'compiler': 'One of [' + config['compiler-list'] + '], repeat to specify multiple compilers',
    'environment': 'One of [' + config['environment-list'] + '], repeat to specify multiple environments',
    'experiment': 'Path to experiment configuration file',
    'help': 'Display this help',
    'implementation': 'One of [' + config['implementation-list'] + '], repeat to specify multiple implementations',
    'input-size': 'One of [' + pointer.get(config.schema, '/definitions/experiment/properties/input-size/enum') + '], defaults to medium',
    'iteration-number': 'Number of times to execute the benchmark',
    'platform': 'Path to a configuration file describing the current hardware configuration',
    'skip-output-verification': 'Do not perform verification of output results'
  }
  var parsed = nopt(knownOpts, shortHands)

  if (parsed.help) {
    var usage = noptUsage(knownOpts, shortHands, description)
    console.log(usage)
    process.exit(1)
  }

  if (parsed.clean) {
    shelljs.rm('-rf', path.join(suiteRoot, '/runs'))
    process.exit(0)
  }

  var options = {
    'platform': JSON.parse(fs.readFileSync(parsed.hasOwnProperty('platform') ? parsed['platform'] : path.join(suiteRoot, '/platforms/mba-2011/platform.json')))
  }

  // Build benchmarks if built versions are not available

  // Load builds
  var run = {
    results: {},
    platform: options.platform,
    experiment: {
      'type': 'experiment',
      'short-name': 'default',
      'input-size': parsed['input-size'] || 'medium',
      'iteration-number': parsed['iteration-number'] || 1
    }
  }

  var builds = parsed.build || []
  if (builds.length === 0) {
    for (var b in config.builds) {
      builds.push('builds/' + b)
    }
  } else {
    builds = builds.map(function (b) {
      var m = b.match(/.*builds\/([a-zA-Z0-9]+).*/)
      if (m === null) {
        throw new Error('Invalid build path ' + b)
      }
      return 'builds/' + m[1]
    })
  }

  var environments = (parsed.environments || config['environment-list']).map(function (e) {
    return config.environments[e]
  })

  function valid (compiler, environment) {
    var targetLanguages = compiler['target-languages']
    var supportedLanguages = environment['supported-languages']

    var validLanguage = false
    for (var i = 0; i < targetLanguages.length; ++i) {
      for (var j = 0; j < supportedLanguages.length; ++j) {
        validLanguage = validLanguage || (targetLanguages[i] === supportedLanguages[j])
      }
    }
    return validLanguage
  }

  builds.forEach(function (configPath) {
    var buildConfig = deepcopy(pointer.get(config, '/' + configPath))

    environments.forEach(function (env) {
      if (!valid(buildConfig.compiler, env)) {
        return
      }

      var runConfig = deepcopy(buildConfig)
      runConfig.experiment = {
        'type': 'experiment',
        'input-size': run.experiment['input-size'],
        'input-file': [{'expand': '/experiment/input-size'}, {'config': '/benchmark/random-seed'}],
        'output-file': pointer.has(runConfig, '/benchmark/output-file')
          ? { 'config': '/benchmark/output-file' } : { 'file': './output.csv' }
      }
      runConfig.environment = env
      // Expand run-time arguments
      configLib.expand(runConfig, {strict: true})

      // console.log(runConfig)

      var result = {
        build: runConfig,
        experiment: run.experiment,
        platform: run.platform,
        environment: env,
        'times': []
      }

      console.log('-------------- ' + runConfig.benchmark['short-name'] +
        ',' + runConfig.implementation['short-name'] +
        ',' + runConfig.compiler['short-name'] +
        ',' + run.platform['short-name'] +
        ',' + env['short-name'] +
        ' --------------')

      for (var i = 0; i < run.experiment['iteration-number']; ++i) {
        if (parsed.verbose) {
          console.log('************** Iteration ' + i + ' ************')
        }
        var output = executeRun(runConfig, parsed)
        result.times.push(output.time)
      }

      var hash = crypto.createHash('sha1')
      hash.update(JSON.stringify({
        build: result.build,
        experiment: runConfig.experiment,
        platform: result.platform
      }))
      run.results[hash.digest('hex')] = result
    })
  })

  var silentState = shelljs.config.silent
  shelljs.config.silent = true
  run.time = moment().format()
  var dir = path.join(suiteRoot, '/runs/', run.time)
  shelljs.mkdir('-p', dir)
  shelljs.ln('-s', dir, path.join(suiteRoot, '/runs/latest'))
  JSON.stringify(run, null, '  ').to(path.join(dir, '/run.json'))
  shelljs.config.silent = silentState
})
